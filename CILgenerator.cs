/*
  Int64 compiler - Common Intermediate Language (CIL) code generator.
  
  Copyright (C) 2013 Ariel Ortiz, ITESM CEM
                     Emmanuel Byrd, ITESM CEM
                     Carlos Reyes, ITESM CEM
                     Diego Rodríguez, ITESM CEM  
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;
using System.Collections.Generic;

namespace Int64Proy {

    class CILGenerator {

        SymbolTable localTable;
        SymbolTable GlobalVariables;
        FunctionTable FuncTable;
        TableDictionary LocalVariableTableDictionary;
        Stack<string> breakLabels;
        Stack<string> continueLabels;

        int labelCounter = 0;
        int variableCounter = 0;

        //-----------------------------------------------------------
        string GenerateLabel() {
            return String.Format("${0:000000}", labelCounter++);
        }    
        
        string GenerateVariable() {
            return String.Format("'$var{0:000}'", variableCounter++);
        }   

        //-----------------------------------------------------------

        public CILGenerator(SymbolTable GlobalVariables, FunctionTable FuncTable, TableDictionary LocalVariableTableDictionary) {
            this.GlobalVariables = GlobalVariables;
            this.FuncTable = FuncTable;
            this.LocalVariableTableDictionary = LocalVariableTableDictionary;
            
            this.breakLabels = new Stack<string>();
            this.continueLabels = new Stack<string>();
        }


        public string Visit(Def_List_Node node) { // el Nodo principal
            string globVar ="";
            foreach (var s in GlobalVariables){
                globVar += "\t.field public static int64 '" + s.Key + "'\n";
            }
            
            string funDec="";
            foreach (var c in node.children){
                if (c.GetType().IsAssignableFrom(typeof(Fun_Def_Node))){
                    funDec += Visit((dynamic) c);
                }
            }
            
            return "// Code generated by the Int64 compiler.\n\n" 
                + ".assembly 'Int64' {}\n\n"
                + ".assembly extern 'int64lib' {}\n\n"
                + ".class public 'Int64Program' extends ['mscorlib']'System'.'Object' {\n\n" 
                + globVar
                + funDec
                + "}\n";
        }
        
        public string Visit(Id_Node node){
            
            string variableCall="";
            if (localTable.Contains(node.AnchorToken.Lexeme)){
                switch (localTable[node.AnchorToken.Lexeme]){
                    case Type.PARAM: // si es parámetro
                        variableCall = "ldarg '"+node.AnchorToken.Lexeme+"'";
                        break;
                    case Type.LOCAL: // si es una variable local
                        variableCall = "ldloc '"+node.AnchorToken.Lexeme+"'";
                        break;
                }
            }else{
                // por haber hecho ya el análisis semántico la variable debió haber sido declarada como global
                variableCall = "ldsfld int64 'Int64Program'::'"+node.AnchorToken.Lexeme+"'";
            }
            return "\t\t"+variableCall+"\n";
        }
        
        public string Visit(Fun_Def_Node node){
            localTable = LocalVariableTableDictionary[node.AnchorToken.Lexeme];
            
            string funFirm ="\t.method public static int64 '"+node.AnchorToken.Lexeme+"'(";
            bool firstParamPassed = false;
            foreach (var c in node[0][0]){
                if (firstParamPassed){
                    funFirm += ", ";
                }
                funFirm += "int64 '"+c.AnchorToken.Lexeme+"'";
                firstParamPassed = true;
            }
            funFirm += "){\n";
            
            if (node.AnchorToken.Lexeme == "main"){
                funFirm += "\t.entrypoint\n";
            }
            
            foreach (var c in LocalVariableTableDictionary[node.AnchorToken.Lexeme]){
                if (c.Value == Type.LOCAL){
                    funFirm += "\t\t.locals init (int64 '"+c.Key+"')\n";
                }
            }
            funFirm += Visit((dynamic) node[2]); // el tercer hijo siempre es un Stmt_List_Node
            
            return funFirm+
                    "\t\tldc.i8 0\n"+
                    "\t\tret\n"+
                    "\t}\n\n";
        }
        
        public string Visit(Stmt_List_Node node){ 
            string s ="";
            foreach (var n in node.children){
                if (n.GetType().IsAssignableFrom(typeof(Fun_Call_Node))){
                    s += Visit((dynamic) n)+
                        "\t\tpop\n"+
                        "\t\t//called pop because uncatched value in "+n.AnchorToken+"\n";
                }else{
                    s+= Visit((dynamic) n); // tendrá 0 o más hijos de tipo desconocido, podrán ser nodos Empty_Node
                }
            }
            return s; 
        }
        
        public string Visit(Assign_Node node){
            string variableStore="";
            if (localTable.Contains(node[0].AnchorToken.Lexeme)){
                switch (localTable[node[0].AnchorToken.Lexeme]){
                    case Type.PARAM: // si es parámetro
                        variableStore = "starg '"+node[0].AnchorToken.Lexeme+"'";
                        break;
                    case Type.LOCAL: // si es una variable local
                        variableStore = "stloc '"+node[0].AnchorToken.Lexeme+"'";
                        break;
                }
            }else{
                variableStore = "stsfld int64 'Int64Program'::'"+node[0].AnchorToken.Lexeme+"'";
            }
            return Visit((dynamic) node[1]) + "\t\t"+variableStore+"\n\n"; //el hijo con la expresión a evaluar, de tipo desconocido
        }
        
        public string Visit(Fun_Call_Node node){ //anchorToken tiene el nombre de la función
            string functionCall;
            switch (node.AnchorToken.Lexeme){
                case "printi":
                    functionCall = "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'Printi'(int64)\n";
                    break;
                case "printc":
                    functionCall = "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'Printc'(int64)\n";
                    break;
                case "prints":
                    functionCall = "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'Prints'(int64)\n";
                    break;
                case "println":
                    functionCall = "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'Println'()\n";
                    break;
                case "readi":
                    functionCall = "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'Readi'()\n";
                    break;
                case "reads":
                    functionCall = "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'Reads'()\n";
                    break;
                case "new":
                    functionCall = "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'New'(int64)\n";
                    break;
                case "size":
                    functionCall = "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'Size'(int64)\n";
                    break;
                case "add":
                    functionCall = "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'Add'(int64, int64)\n";
                    break;
                case "get":
                    functionCall = "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'Get'(int64, int64)\n";
                    break;
                case "set":
                    functionCall = "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'Set'(int64, int64, int64)\n";
                    break;
                case "pow":
                    functionCall = "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'Pow'(int64, int64)\n";
                    break;
                default:
                    string arguments = "";
                    int n = FuncTable[node.AnchorToken.Lexeme];
                    if (n>0){
                        arguments += "int64";
                    }
                    for (int i = 0; i < n-1; i++){
                        arguments+= ", int64";
                    }
                    functionCall = "\t\tcall int64 class 'Int64Program'::'"+node.AnchorToken.Lexeme+"'("+arguments+")\n";
                    break;
            }
            return Visit((dynamic) node[0])+functionCall;
        }
        
        public string Visit(Break_Node node){
            return "\t\tbr "+breakLabels.Peek()+"\n";
        }
        
        public string Visit(Continue_Node node){
            return "\t\tbr "+continueLabels.Peek()+"\n";
        }
        
        public string Visit(Return_Node node){
            return Visit((dynamic) node[0]) +
                    "\t\tret\n";
        }
        
        public string Visit(Empty_Node node){
            return "";
        }
        
        public string Visit(Expr_List_Node node){
            return VisitChildren(node);
        }
        
        public string Visit(Stmt_If_Node node){
            string elseLabel = GenerateLabel();
            
            string result = Visit((dynamic) node[0]);
            
            if (CountChildren(node) == 3){
                string exitLabel = GenerateLabel();
                
                result += "\t\tbrfalse "+elseLabel+"\n"+
                            Visit((dynamic) node[1])+"\n"+
                            "\t\tbr "+exitLabel+"\n"+
                            "\t\t"+elseLabel+":\n"+
                            Visit((dynamic) node[2])+"\n"+
                            "\t\t"+exitLabel+": \n";   // si hay muchos else-if entonces al final habrá muchos labels usados para salir de la condición, no afecta el comportamiento pero no es óptimo
            }else{
                result += "\t\tbrfalse "+elseLabel+"\n"+
                            Visit((dynamic) node[1])+"\n"+
                            "\t\t"+elseLabel+": \n";
            }
            return result;
        }
        
        public string Visit(Else_Node node){
            // El Anchor Token de este node será 'else' o ':' , dependiendo de dónde fue llamado, su hijo son los statements a ejecutar en caso de "false"
            return Visit((dynamic) node[0]); 
        }
        
        public string Visit(Stmt_Switch_Node node){
            
            string switchVariable = GenerateVariable();
            
            string r = "\t//---initializing switch vairables\n"+   ///
                        "\t\t.locals init (int64 "+switchVariable+")\n"+
                        Visit((dynamic) node[0])+
                        "\t\tstloc "+switchVariable+"\n\n";
            
            string exitLabel = GenerateLabel();
                        
            foreach (var c in node[1].children){ // cada c es un Case_Node
            
                string elseLabel = GenerateLabel();
                
                r += "\t//---pushing 0 for easier comparison\n"+
                    "\t//--- begining of case block\n"+
                    "\t\tldc.i8 0\n"; // para facilitar el escribir código, la primer comparación hace OR con 0, la segunda hace OR con el resultado...
               
                foreach(var d in c[0].children){ // cada d es un Lit_Simple_Node
                    r += "\t//---one case\n"+
                        "\t\tldc.i8 "+d.AnchorToken.Lexeme+"\n"+
                        "\t\tldloc "+switchVariable+"\n"+
                        "\t\tceq\n"+
                        "\t\tconv.i8\n"+
                        "\t\tor\n";
                }
                r += "\t//--if this case evaluation returned false\n"+
                        "\t\tbrfalse "+elseLabel+"\n\n"+
                        Visit((dynamic) c[1])+
                        "\t\tbr "+exitLabel+"\n"+
                        "\t\t"+elseLabel+":\n"+
                        "\t//--end of this case evaluation\n";
            }
            return r+
                    "\t//--Visiting the Default option\n"+
                    Visit((dynamic) node[2])+
                    "\t\t"+exitLabel+":\n"+
                    "\t//--End of switch block\n";
        }
        
        // lo visitará el padre
        /*
        public string Visit(Case_List_Node node){
            //foreach (var n in node.children) {
            //    Visit((dynamic) n); //cada uno de estos es un case diferente
            //}
            
            return "\t\tCase_List_Node Aun no implementado!!!!\n";
        }
        
        // lo visitará el abuelo
        public string Visit(Case_Node node){
            //Visit((dynamic) node[0]); //lit-list
            //Visit((dynamic) node[1]); //stmt-list
            
            return "\t\tCase_Node Aun no implementado!!!!\n";
        }
        */
        
        // Los hijos de este nodo representan los datos de un array o las posibilidades de un case
        // Se visitaran desde el nodo padre
        /*
        public string Visit(Lit_List_Node node){ // representa los datos de un array o de un case
            foreach (var n in node.children) {
                Visit((dynamic) n); //cada uno de estos es un nodo de literal simple
                // true, false, int_literal, int_bin, int_hex, int_oct, int_dec, char
            }
        }
        */
        
        public string Visit(Lit_Simple_Node node){
            // el AnchorToken de este node es una literal simple, el equivalente a los nodos de true, false, int_literal, int_bin, etc, etc o un STRING
            // todos, excepto los string ya están guardados como un string de los números que representan
            string r = "";
            if (node.AnchorToken.Category == TokenCategory.STRING){
                // los strings son guardados como Lexemes que empiezan y terminan con comillas dobles
                string s = node.AnchorToken.Lexeme;
                string stringHandle = GenerateVariable();
                
                int l = s.Length;
                s = s.Substring(1, l-2); //el STRING ya tiene los caracteres correctos
                r +=    "\t\t.locals init (int64 "+stringHandle+")\n"+
                        "\t\tldc.i8 0\n"+
                        "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'New'(int64)\n"+
                        "\t\tstloc "+stringHandle+"\n";
                
                char[] cA = s.ToCharArray();
                foreach (char c in cA){
                    r+="\t\tldloc "+stringHandle+"\n"+                                      //duplicar en el stack, el Handle del arreglo
                        "\t\tldc.i8 "+ ((int)c).ToString()+"\n"+                            //poner en el stack el valor del caracter
                        "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'Add'(int64, int64)\n"+ //consumir el handle duplicado y el valor del caracter
                        "\t\tpop\n";                                                        //sacar el 0 que regresa la función "Add"
                        // en este momento sigue hasta arriba del stack el handle del arreglo para usarse
                }
                return r+
                        "\t\tldloc "+stringHandle+"\n";
            }else{
                r = node.AnchorToken.Lexeme;
                return "\t\tldc.i8 "+r+"\n";
            }
        }
        
        public string Visit(Array_Node node){
            //Visit((dynamic) node[0]); //siempre tiene un hijo, siendo una lista de literales, estas literales no serán STRINGS
            if (CountChildren(node) == 1){
                string r = "";
                r +=    "\t\tldc.i8 0\n"+
                        "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'New'(int64)\n";
                
                foreach (var n in node[0].children){
                    r+="\t\tdup\n";                                                         //duplicar en el stack, el Handle del arreglo
                        if (n.AnchorToken.Category == TokenCategory.MINUS){
                            r+= "\t\tldc.i8 0\n"+
                                "\t\tldc.i8 "+n[1].AnchorToken.Lexeme+"\n"+
                                "\t\tsub\n";
                        }else{
                            r+= "\t\tldc.i8 "+ n.AnchorToken.Lexeme+"\n";                           //poner en el stack el valor del caracter
                        }
                    r+= "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'Add'(int64, int64)\n"+ //consumir el handle duplicado y el valor del caracter
                        "\t\tpop\n";                                                        //sacar el 0 que regresa la función "Add"
                        // en este momento sigue hasta arriba del stack el handle del arreglo para usarse
                }
                return r;
            }else{
                return "\t\tldc.i8 0\n"+
                        "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'New'(int64)\n"; // es un arreglo vacío
            }
        }
        
        public string Visit(Stmt_While_Node node){ // Anchor Token: While
            string r = "";
            string firstLabel = GenerateLabel();
            string lastLabel = GenerateLabel();
            
            breakLabels.Push(lastLabel);
            continueLabels.Push(firstLabel);
            
            r+= "\t\t"+firstLabel+": \n"+ Visit((dynamic) node[0])+"\n"+
                "\t\tbrfalse "+lastLabel+"\n"+
                Visit((dynamic) node[1])+"\n"+
                "\t\tbr "+firstLabel+"\n"+
                "\t\t"+lastLabel+": \n";
            
            breakLabels.Pop();
            continueLabels.Pop();
            return r;
        }
        
        public string Visit(Stmt_Do_While_Node node){ //AnchorToken: Do
            string r = "";
            string statementLabel = GenerateLabel();
            string firstLabel = GenerateLabel();
            string lastLabel = GenerateLabel();
            
            breakLabels.Push(lastLabel);
            continueLabels.Push(firstLabel);
            
            r += "\t\t"+statementLabel + ": \n"+ Visit((dynamic) node[0])+"\n"+
                "\t\t"+firstLabel + ": \n"+ Visit((dynamic) node[1])+"\n"+
                "\t\tbrtrue "+statementLabel+"\n"+
                "\t\t"+lastLabel+": \n";
            
            breakLabels.Pop();
            continueLabels.Pop();
            return r;
        }
        
        public string Visit(Stmt_For_Node node){
            string breakLabel = GenerateLabel();
            string continueLabel = GenerateLabel();
            string loopLabel = GenerateLabel();
            breakLabels.Push(breakLabel);
            continueLabels.Push(continueLabel);
            string r = "";
            
            string indice = GenerateVariable();
            string arrayHandle = GenerateVariable();
            string size = GenerateVariable();
            
            r +=    "\n\t\t//For Loop begin\n\n"+
                    "\t\t.locals init (int64 "+indice+")  //index variable\n"+
                    "\t\t.locals init (int64 "+arrayHandle+") //array handle\n"+
                    "\t\t.locals init (int64 "+size+")  //size catcher\n"+
                    "\t\tldc.i8 0\n"+
                    "\t\tstloc "+ indice + "\n"+
                    Visit((dynamic) node[0][1])+ // el nodo con la expresión que genera el Handle del arreglo sobre el que va a iterar
                    "\t\tstloc "+ arrayHandle + "\n"+
                    "\t\tldloc "+ arrayHandle + "\n"+
                    "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'Size'(int64)\n"+
                    "\t\tstloc "+ size + "\n"+
                    "\t\t"+loopLabel+": \n"+ // los ciclos inician aqui
                    "\t\tldloc "+indice+"\n"+
                    "\t\tldloc "+size+"\n"+
                    "\t\tclt\n"+            // saber si el indice es menor que el tamaño del arreglo
                    "\t\tconv.i8\n"+
                    "\t\tbrfalse "+breakLabel+"\n"+
                    "\t\tldloc "+arrayHandle+"\n"+
                    "\t\tldloc "+indice+"\n"+
                    "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'Get'(int64, int64)\n"; // obtener el valor en el índice solicitado, dentro del arreglo mencionado
            if (localTable.Contains(node[0][0].AnchorToken.Lexeme)){
                switch (localTable[node[0][0].AnchorToken.Lexeme]){  //el nodo con la variable a usar en las iteraciones
                    case Type.PARAM: // si es parámetro
                        r += "\t\tstarg '"+node[0][0].AnchorToken.Lexeme+"'\n";
                        break;
                    case Type.LOCAL: // si es una variable local
                        r += "\t\tstloc '"+node[0][0].AnchorToken.Lexeme+"'\n";
                        break;
                }   
            }else{
                r += "\t\tstsfld int64 'Int64Program'::'"+node[0][0].AnchorToken.Lexeme+"'\n";
            }
            r +=    Visit((dynamic) node[1]); // el nodo con los statements que se ejecutarán dentro del ciclo
                    
            r +=    "\t\t"+continueLabel+": \n"+
                    "\t\tldc.i8 1\n"+
                    "\t\tldloc "+indice+"\n"+
                    "\t\tadd\n"+
                    "\t\tstloc "+indice+"\n"+
                    "\t\tbr "+loopLabel+"\n"+
                    "\t\t"+breakLabel+": \n";
                    
                    //para dejar 0 en la variable que se usó en el ciclo
            /*
            r +=    "\t\tldc.i8 0\n";
                    
            if (localTable.Contains(node[0][0].AnchorToken.Lexeme)){
                switch (localTable[node[0][0].AnchorToken.Lexeme]){  //el nodo con la variable a usar en las iteraciones
                    case Type.PARAM: // si es parámetro
                        r += "\t\tstarg '"+node[0][0].AnchorToken.Lexeme+"'\n";
                        break;
                    case Type.LOCAL: // si es una variable local
                        r += "\t\tstloc '"+node[0][0].AnchorToken.Lexeme+"'\n";
                        break;
                }   
            }else{
                r += "\t\tstsfld int64 'Int64Program'::'"+node[0][0].AnchorToken.Lexeme+"'\n";
            }
                    // termina lo usado para dejar 0 en la variable que se usó en el ciclo
            */
            breakLabels.Pop();
            continueLabels.Pop();
            return r;
        }
        
        //Lo visitará el padre
        /*
        public string Visit(In_Node node){ //AnchorToken: in
            //Visit((dynamic) node[0]); //nombre de la variable
            //Visit((dynamic) node[1]); //expresión para saber dónde comenzar
            
            return "\t\tIn_Node Aun no implementado!!!!\n";
        }
        */
        
        //--------------
        
        public string Visit(Default_Node node){
            string r = "";
            return r+Visit((dynamic) node[0]);
        }
        
        //--- litearles simples
        
        public string Visit(True_Node node){
            return "\t\tldc.i8 1\n";
        }
        
        public string Visit(False_Node node){
            return "\t\tldc.i8 0\n";
        }
        
        public string Visit(Int_Lit_Node node){
            return "\t\tldc.i8 " + node.AnchorToken.Lexeme +"\n";
        }
        
        public string Visit(Int_Bin_Node node){
            return "\t\tldc.i8 " + node.AnchorToken.Lexeme +"\n";
        }
        
        public string Visit(Int_Dec_Node node){
            return "\t\tldc.i8 " + node.AnchorToken.Lexeme +"\n";
        }
        
        public string Visit(Int_Hex_Node node){
            return "\t\tldc.i8 " + node.AnchorToken.Lexeme +"\n";
        }
        
        public string Visit(Int_Oct_Node node){
            return "\t\tldc.i8 " + node.AnchorToken.Lexeme +"\n";
        }
        
        public string Visit(Character_Node node){
            return "\t\tldc.i8 " + node.AnchorToken.Lexeme +"\n";
        }
        //--------------- Arithmetic Operators--------------------------------------------
        public string Visit(Unary_Node node) {
            string r ="";
            switch (node.AnchorToken.Category){
                case TokenCategory.PLUS:
                    r += Visit((dynamic) node[0]);
                    break;
                case TokenCategory.MINUS:
                    r += "\t\tldc.i8 0\n"+
                            Visit((dynamic) node[0])+
                            "\t\tsub\n";
                    break;
                case TokenCategory.NEG:
                    r += Visit((dynamic) node[0])+
                            "\t\tldc.i8 0\n"+
                            "\t\tceq\n"+
                            "\t\tconv.i8\n";
                    break;
                case TokenCategory.BITWISE_NOT: 
                    r += Visit((dynamic) node[0])
                            + "\t\tnot\n";
                    break;
            }
            return r;
        }
        
        public string Visit(Add_Node node) {
            string r = "";
            switch (node.AnchorToken.Category){
                case TokenCategory.PLUS:
                    r += VisitBinaryOperator("add.ovf", node);
                    break;
                case TokenCategory.MINUS:
                    r += VisitBinaryOperator("sub.ovf", node);
                    break;
            }
            return r;
        }
        //----------------------------------------
        // Ya esta en func_call_node
        public string Visit(Pow_Node node){
            return VisitChildren(node)+
                    "\t\tcall int64 class['int64lib']'Int64Proy'.'Utils'::'Pow'(int64, int64)\n";
        }
        
        //----------------------------------------
        public string Visit(Mul_Node node) {
            string r = "";
            switch (node.AnchorToken.Category){
                case TokenCategory.MUL:
                    r += VisitBinaryOperator("mul.ovf", node);
                    break;
                case TokenCategory.DIVISION:
                    r += VisitBinaryOperator("div", node);
                    break;
                case TokenCategory.REMAINDER:
                    r += VisitBinaryOperator("rem", node);
                    break;
            }
            return r;
        }
        
        //------------------------
        
        public string Visit(BitAnd_Node node) {
            return VisitBinaryOperator("and", node);
        } 
        
        //------------------------
        
        public string Visit(BitOr_Node node) {
            string r = "";
            switch (node.AnchorToken.Category){
                case TokenCategory.BITWISE_OR:
                    r += VisitBinaryOperator("or", node);
                    break;
                case TokenCategory.BITWISE_XOR:
                    r += VisitBinaryOperator("xor", node);
                    break;
            }
            return r;
        } 
        //------------------------
        
        public string Visit(BitShift_Node node) {
            string r = "";
            switch (node.AnchorToken.Category){
                case TokenCategory.BITWISE_SHIFT_LEFT:
                    r += VisitBinaryOperator("conv.i4\n\t\tshl", node);
                    break;
                case TokenCategory.BITWISE_SHIFT_RIGHT:
                     r += VisitBinaryOperator("conv.i4\n\t\tshr", node);
                    break;
                case TokenCategory.BITWISE_UNSIGNED_SHIFT_RIGHT:
                     r += VisitBinaryOperator("conv.i4\n\t\tshr.un", node);
                    break;
            }
            return r;
        }
        
        //------------------------
        
        public string Visit(And_Node node) {
            return VisitBinaryOperator("and", node);
        }
        
        //------------------------
        
        public string Visit(Or_Node node) {
            return VisitBinaryOperator("or", node);
        }
        
        //------------Comparison and relational operators------------
        
        public string Visit(Comp_Node node) {
            string r = "";
            switch (node.AnchorToken.Category){
                case TokenCategory.EQUAL:
                    r += VisitBinaryOperator("ceq", node);
                    break;
                case TokenCategory.NOTEQUAL:
                    r += VisitBinaryOperator("ceq", node)+
                        "\t\tldc.i8 0\n"+
                        "\t\tceq\n"+
                        "\t\tconv.i8\n"; 
                    break;
            }
            return r;
        }
        
        public string Visit(Rel_Node node) {
            string r = "";
            switch (node.AnchorToken.Category){
                case TokenCategory.LESS:
                    r += VisitBinaryOperator("clt", node);
                    break;
                case TokenCategory.LESSEQUAL: //hecho como la negación de ser mayor que
                    r += VisitBinaryOperator("cgt", node)+
                        "\t\tldc.i8 0\n"+
                        "\t\tceq\n"+
                        "\t\tconv.i8\n"; 
                    break;
                case TokenCategory.GREATER:
                    r += VisitBinaryOperator("cgt", node);
                    break;
                case TokenCategory.GREATEREQUAL: // hecho como la negación de ser menor que
                    r += VisitBinaryOperator("clt", node)+
                        "\t\tldc.i8 0\n"+
                        "\t\tceq\n"+
                        "\t\tconv.i8\n"; 
                    break;
            }
            return r;
        }

        //-----------------------------------------------------------
        string VisitChildren(Node node) {
            var sb = new StringBuilder();
            foreach (var n in node.children) {
                sb.Append(Visit((dynamic) n));
            }
            return sb.ToString();
        }

        //-----------------------------------------------------------
        string VisitBinaryOperator(string op, Node node) {
            return Visit((dynamic) node[0])
                + Visit((dynamic) node[1])
                + "\t\t" + op + "\n"
                + "\t\tconv.i8\n";            
        }
        
        int CountChildren(Node node){
            int c = 0;
            foreach (var n in node.children){
                c++;
            }
            return c;
        }
    }
}
